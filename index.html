<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VAST 2019 MC2</title>
    <script src="d3.v7.min.js"></script>
</head>
<body>
    
    <script>
        // Authored by Julia Santos Nothaft and Patrick Feeney
        function geographicalPlot(data)
        {
            // set spacing
            img_width = 995;
            img_height = 823;
            margin = ({top: 40, right: 40, bottom: 40, left: 40});
            width = margin.left + img_width + margin.right;
            height = margin.top + img_height + margin.bottom;
            // create scales
            xScale = d3.scaleLinear()
                .domain([-120.0, -119.711751])
                .range([margin.left, margin.left + img_width])
            yScale = d3.scaleLinear()
                .domain([0.0, 0.238585])
                .range([img_height + margin.top, margin.top])
            colorScale = d3.scaleSequential(d3.extent(data, d => d.val), d3.interpolateReds);
            // create axes
            yAxis = g => g
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale));
            xAxis = g => g
                .attr("transform", `translate(0,${img_height + margin.top})`)
                .call(d3.axisBottom(xScale));
            // create the chart
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("id", "geoSVG");
            // background image
            svg.append("svg:image")
                .attr("xlink:href", "MC2/data/StHimarkLabeledMap.png")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            // axes and color bar
            svg.append("g")
                .call(xAxis);
            svg.append("g")
                .call(yAxis);
            // create points
            geographicalPlotPoints(data, svg);
            return svg.node();
        }

        function geographicalPlotPoints(data, svg, min_val=0, max_val=10000)
        {
            // filter data before creating points
            filtered = data.filter((d) => {return d.val >= min_val && d.val <= max_val;});
            // points
            svg.append("g")
                .attr("stroke-width", 1.5)
                .attr("font-family", "sans-serif")
                .attr("font-size", 10)
                .attr("id", "geoPoints")
                .selectAll("path")
                .data(filtered)
                .join("path")
                    .attr("transform", d => `translate(${xScale(d.long)},${yScale(d.lat)})`)
                    .attr("d", (d) => d3.symbol().type(d3.symbolCircle)())
                    .attr("fill", d => colorScale(d.val))
                    .append("title")
                        .text(d => `${d.val}`);
        }

        function sensorHistogram(sensorData)
        {
            // modified from this tutorial:
            // https://observablehq.com/@d3/histogram
            // set spacing
            plot_width = 995;
            plot_height = 200;
            margin = ({top: 40, right: 40, bottom: 40, left: 40});
            width = margin.left + plot_width + margin.right;
            height = margin.top + plot_height + margin.bottom;
            // set parameters
            thresholds = 40;
            insetLeft = .5;
            insetRight = .5;
            // compute values
            const X = d3.map(sensorData, d => d.val);
            const Y0 = d3.map(sensorData, () => 1);
            const I = d3.range(X.length);
            // compute bins
            const bins = d3.bin().thresholds(thresholds).value(i => X[i])(I);
            const Y = Array.from(bins, I => d3.sum(I, i => Y0[i]));
            // create domains
            xDomain = [bins[0].x0, bins[bins.length - 1].x1];
            yDomain = [0, d3.max(Y)];
            // create scales and axes
            const xScale = d3.scaleLinear(xDomain, [margin.left, margin.left + plot_width]);
            const yScale = d3.scaleSymlog(yDomain, [margin.top + plot_height, margin.top]);
            const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
            const yAxis = d3.axisLeft(yScale).tickValues([1, 10, 100, 1000, 10000]);
            // create public xScale for brush function
            sensorHistXScale = xScale
            // create view
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto; height: intrinsic;");
            // Initialize brush component
            const defaultSelection = xScale.range();
            const brush = d3.brushX()
                .extent([[margin.left, margin.top], [width - margin.right, height - margin.bottom]])
                .on("end", updateFromGeoBrush);
            // Append brush component
            const gbrush = svg.append("g")
                .attr("class", "brush")
                .call(brush)
                .call(brush.move, defaultSelection);
            // create y axis
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(yAxis)
                .call(g => g.select(".domain").remove())
                .call(g => g.selectAll(".tick line").clone()
                    .attr("x2", plot_width)
                    .attr("stroke-opacity", 0.1))
                .call(g => g.append("text")
                    .attr("x", -margin.left)
                    .attr("y", 10)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "start")
                    .text("Frequency"));
            // create x axis
            svg.append("g")
                .attr("transform", `translate(0,${margin.top + plot_height})`)
                .call(xAxis)
                .call(g => g.append("text")
                    .attr("x", margin.left + plot_width)
                    .attr("y", 27)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .text("Radiation"));
            // create bars
            svg.append("g")
                .attr("fill", "blue")
                .selectAll("rect")
                .data(bins)
                .join("rect")
                .attr("x", d => xScale(d.x0) + insetLeft)
                .attr("width", d => Math.max(0, xScale(d.x1) - xScale(d.x0) - insetLeft - insetRight))
                .attr("y", (d, i) => yScale(Y[i]))
                .attr("height", (d, i) => yScale(0) - yScale(Y[i]))
                .append("title")
                .text((d, i) => [`${d.x0} â‰¤ x < ${d.x1}`, Y[i]].join("\n"));

            return svg.node();
        }

        async function loadCSV(path, row_conv)
        {
            const response = await fetch(path);
            return d3.csvParse(await response.text(), row_conv);
        }

        async function loadData(start_date="2020-04-06T04:00:10", end_date="2020-04-06T04:00:30",
                                min_val=0, max_val=10000, id=null)
        {
            data_str = "data?start_date=" + start_date + "&"
                + "end_date=" + end_date + "&"
                + "min_val=" + min_val.toString() + "&"
                + "max_val=" + max_val.toString();
            if (id != null)
                data_str += "&tag=" + id;
            const response = await fetch(data_str);
            return response.json();
        }

        async function updateFromGeoBrush()
        {
            var brush = d3.select(".brush").node();
            if (brush != null)
            {
                var selection = d3.brushSelection(brush);
                var val_range = selection.map(sensorHistXScale.invert, sensorHistXScale);
                d3.select("#geoPoints").remove();
                geographicalPlotPoints(data, d3.select("#geoSVG"), val_range[0], val_range[1]);
            }
        }
        
        async function main()
        {
            // load CSVs
            // static_locs = await loadCSV("MC2/data/StaticSensorLocations.csv",
            //     (d) => { return {
            //         id: parseInt(d["Sensor-id"]),
            //         lat: parseFloat(d.Lat),
            //         long: parseFloat(d.Long),
            //     }; }
            // );
            // static_data = await loadCSV("MC2/data/StaticSensorReadings.csv",
            //     (d) => { return {
            //         time: new Date(d.Timestamp),
            //         id: parseInt(d["Sensor-id"]),
            //         val: parseFloat(d.Value),
            //         lat: static_locs.find(loc => loc.id == parseInt(d["Sensor-id"])).lat,
            //         long: static_locs.find(loc => loc.id == parseInt(d["Sensor-id"])).long,
            //     }; }
            // );
            // mobile_data = await loadCSV("MC2/data/MobileSensorReadings.csv",
            //     (d) => { return {
            //         time: new Date(d.Timestamp),
            //         id: parseInt(d["Sensor-id"]),
            //         user: d[" User-id"].trim(),
            //         lat: parseFloat(d.Lat),
            //         long: parseFloat(d.Long),
            //         val: parseFloat(d.Value),
            //     }; }
            // );
            data = await loadData();
            d3.select("body").append("div").append(() => geographicalPlot(data));
            d3.select("body").append("div").append(() => sensorHistogram(data));
        }

        main();
    </script>
</body>
</html>
