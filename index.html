<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VAST 2019 MC2</title>
    <script src="d3.v7.min.js"></script>
</head>
<body>
    
    <script>
        // Authored by Julia Santos Nothaft and Patrick Feeney
        function geographicalPlot(data)
        {
            // set spacing
            img_width = 995;
            img_height = 823;
            margin = ({top: 40, right: 40, bottom: 40, left: 40});
            width = margin.left + img_width + margin.right;
            height = margin.top + img_height + margin.bottom;
            // create scales
            xScale = d3.scaleLinear()
                .domain([-120.0, -119.711751])
                .range([margin.left, margin.left + img_width])
            yScale = d3.scaleLinear()
                .domain([0.0, 0.238585])
                .range([img_height + margin.top, margin.top])
            colorScale = d3.scaleSequential(d3.extent(data, d => d.val), d3.interpolateReds);
            // create axes
            yAxis = g => g
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale));
            xAxis = g => g
                .attr("transform", `translate(0,${img_height + margin.top})`)
                .call(d3.axisBottom(xScale));
            // create the chart
            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width, height]);
            // background image
            svg.append("svg:image")
                .attr("xlink:href", "MC2/data/StHimarkLabeledMap.png")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            // axes and color bar
            svg.append("g")
                .call(xAxis);
            svg.append("g")
                .call(yAxis);
            // points
            svg.append("g")
                .attr("stroke-width", 1.5)
                .attr("font-family", "sans-serif")
                .attr("font-size", 10)
                .selectAll("path")
                .data(data)
                .join("path")
                    .attr("transform", d => `translate(${xScale(d.long)},${yScale(d.lat)})`)
                    .attr("d", (d) => d3.symbol().type(d3.symbolCircle)())
                    .attr("fill", d => colorScale(d.val))
                    .append("title")
                        .text(d => `${d.val}`);
            return svg.node();
        }

        function sensorHistogram(sensorData)
        {
            // modified from this tutorial:
            // https://observablehq.com/@d3/histogram
            // set spacing
            plot_width = 995;
            plot_height = 200;
            margin = ({top: 40, right: 40, bottom: 40, left: 40});
            width = margin.left + plot_width + margin.right;
            height = margin.top + plot_height + margin.bottom;
            // set parameters
            thresholds = 40;
            insetLeft = .5;
            insetRight = .5;
            // compute values
            const X = d3.map(sensorData, d => d.val);
            const Y0 = d3.map(sensorData, () => 1);
            const I = d3.range(X.length);
            // compute bins
            const bins = d3.bin().thresholds(thresholds).value(i => X[i])(I);
            const Y = Array.from(bins, I => d3.sum(I, i => Y0[i]));
            // create domains
            xDomain = [bins[0].x0, bins[bins.length - 1].x1];
            yDomain = [0, d3.max(Y)];
            // create scales and axes
            const xScale = d3.scaleLinear(xDomain, [margin.left, margin.left + plot_width]);
            const yScale = d3.scaleLinear(yDomain, [margin.top + plot_height, margin.top]);
            const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
            const yAxis = d3.axisLeft(yScale).ticks(height / 40);
            // create view
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto; height: intrinsic;");
            // create y axis
            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(yAxis)
                .call(g => g.select(".domain").remove())
                .call(g => g.selectAll(".tick line").clone()
                    .attr("x2", plot_width)
                    .attr("stroke-opacity", 0.1))
                .call(g => g.append("text")
                    .attr("x", -margin.left)
                    .attr("y", 10)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "start")
                    .text("Frequency"));
            // create x axis
            svg.append("g")
                .attr("transform", `translate(0,${margin.top + plot_height})`)
                .call(xAxis)
                .call(g => g.append("text")
                    .attr("x", margin.left + plot_width)
                    .attr("y", 27)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .text("Radiation"));
            // create bars
            svg.append("g")
                .attr("fill", "blue")
                .selectAll("rect")
                .data(bins)
                .join("rect")
                .attr("x", d => xScale(d.x0) + insetLeft)
                .attr("width", d => Math.max(0, xScale(d.x1) - xScale(d.x0) - insetLeft - insetRight))
                .attr("y", (d, i) => yScale(Y[i]))
                .attr("height", (d, i) => yScale(0) - yScale(Y[i]))
                .append("title")
                .text((d, i) => [`${d.x0} â‰¤ x < ${d.x1}`, Y[i]].join("\n"));

            return svg.node();
        }

        function filterDate(sensorData, startDate, endDate)
        {
            return sensorData.filter((d) => d.time >= startDate && d.time < endDate);
        }

        function maxForLocation(sensorData)
        {
            maxMap = new Map();
            for (d of sensorData)
            {
                key = [d.lat, d.long];
                if (!maxMap.has(key) || maxMap.get(key).val < d.val)
                {
                    maxMap.set(key, d);
                }
            }
            return Array.from(maxMap.values());
        }

        async function loadCSV(path, row_conv)
        {
            const response = await fetch(path);
            return d3.csvParse(await response.text(), row_conv);
        }
        
        async function main()
        {
            // load CSVs
            static_locs = await loadCSV("MC2/data/StaticSensorLocations.csv",
                (d) => { return {
                    id: parseInt(d["Sensor-id"]),
                    lat: parseFloat(d.Lat),
                    long: parseFloat(d.Long),
                }; }
            );
            static_data = await loadCSV("MC2/data/StaticSensorReadings.csv",
                (d) => { return {
                    time: new Date(d.Timestamp),
                    id: parseInt(d["Sensor-id"]),
                    val: parseFloat(d.Value),
                    lat: static_locs.find(loc => loc.id == parseInt(d["Sensor-id"])).lat,
                    long: static_locs.find(loc => loc.id == parseInt(d["Sensor-id"])).long,
                }; }
            );
            mobile_data = await loadCSV("MC2/data/MobileSensorReadings.csv",
                (d) => { return {
                    time: new Date(d.Timestamp),
                    id: parseInt(d["Sensor-id"]),
                    user: d[" User-id"].trim(),
                    lat: parseFloat(d.Lat),
                    long: parseFloat(d.Long),
                    val: parseFloat(d.Value),
                }; }
            );
            // TODO date filtering
            static_filtered = static_data
            static_filtered = filterDate(static_filtered, new Date("04/06/2020"), new Date("04/07/2020"));
            // TODO fix
            static_filtered = maxForLocation(static_filtered);
            d3.select("body").append("div").html(geographicalPlot(static_filtered).outerHTML);
            d3.select("body").append("div").html(sensorHistogram(static_filtered).outerHTML);
        }

        main();
    </script>
</body>
</html>
